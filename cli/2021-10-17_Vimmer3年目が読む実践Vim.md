新卒でVimを覚えて、VSCodeVim入りのVSCodeに一時期浮気して、NeoVimに引っ越し＋cocnvimを覚えてからはNeoVimにどっぷり。
いよいよ3年ぐらい経とうとしているので、まだ実践できていなものを列挙してみる。

完全に自分用だけど、もしかしたら思考がシンクロしがちな人がいたら刺さる部分があるかも。

---

単なる単語消去の際は `daw` がよい。
ドットコマンドとの相性も良い。

挿入ノーマルモード:
挿入モード時に `<C-o>` をタイプするとノーマルモードに遷移するが、そこで何かノーマルコマンドを打つとすぐに挿入モードに戻る。
`<C-o>zz` とすると、挿入モードのまま画面を中央に戻すことができる。
もしかしたら、他の応用を `imap` すると便利かもしれない。

挿入モードから抜けないでレジスタから貼り付け:
挿入モード時に `<C-r>` からレジスタを指定すると、そのレジスタに登録されているものがバッファに入力される。
`<C-r><C-p>` としてからレジスタを指定すると、意図しないインデントなどを防いで、そのままが正しく入力される。
`0` は直前のyankした内容を保存しているらしく、 `<C-r>0` で挿入モードのままヤンクしたテキストを貼り付けることができる。

Expressionレジスタ:
`=` はExpressionレジスタで、 `<C-r>=` とすると挿入モードからプロンプトが出せる。
この間は「コマンドラインモード」に分類されるらしい。
Enterで入力を確定させると、バッファに結果が挿入される。

文字コードを使って特殊文字を入力:
挿入モードで `<C-v>` とし、その後に文字コードを指定する。
みんな文字コードって覚えてるの。。？

ダイグラフによって特殊文字を挿入:
挿入モードでは `<C-k>{char1}{char2}` とする。
ダイグラフのほうが直感的なため、覚えておくといいかも。

置換モード:
ノーマルモードで `R` とタイプすると、置換モードに遷移する。
そもそもこのモードは認識したことがなかったので、見慣れない色にステータスバーが変化するな、と思った。
そのままタイプすると、カーソル位置の単語が入力内容で置換され続ける。
使いそうだけど、あんま使わないか。。

ビジュアルモードの再選択:
ノーマルモードで `<gv>` とすると、直前に選択した範囲を再選択した状態でビジュアルモードに入れる。
覚えておくと、地味に効率化できるかも。

ビジュアルモードの始点・終点をトグルする:
ビジュアルモードで `o` とタイプすると、始点と終点が入れ替わるので、微調整に便利。
通常・行指向・ブロック指向いずれでも直感的な挙動となる。

`gu` と `gU`:
それぞれ小文字化と大文字化。
ドットコマンドを便利に使うためには覚えておきたい。

Vimのコマンドラインモード（Exコマンド）:
何がコマンドラインモード化を理解しておきたい。
コロンを打ったとき、スラッシュで検索するとき、Expressionレジスタにアクセスするときは、すべてコマンドラインモードとなる。

Exコマンドを、アドレスで行範囲を指定する:
`:{start},{end}` で指定できる。
基本は行番号を指定することになるが、いくつか特殊なものがある。

- `:/<html>/+1,/<\/html>/-1`: 合致するタグに挟まれる部分を指定する、オフセットの構文を利用している
- `%`: ファイル全体を示すが、これは `:1,$` と等価であることを意識したい

copyコマンド:
`:6copy.` とすると、「6行目を現在行にコピー」となる
ビジュアルモードで範囲指定してから `:$` とタイプすると、選択範囲が末尾に貼られる。
覚えておくと、案外普段から使えるかもしれない。
`:t` でも等価らしいので、手打ちするときはこちらのほうが早い。
また、レジスタを介さないので、クリーンでもある。

moveコマンド:
`:move` もしくは `:m` でよい。
範囲や移動先の指定方法はcopyと同じ。

Exコマンドの繰り返し:
`@:` で前回のExコマンドを繰り返せる。
単体では覚えにくいので、何らかと関連付けて覚えたい。

normalコマンド:
normalコマンドというと何を指すのか覚えにくいので、具体例で覚えてしまうのが良い。
`:'<'>normal .` は「選択範囲にドットコマンド」となる。
`:%normal A;` は「ファイルのすべての行の行末にセミコロンを追加」となる。
normalコマンドのルールは覚えておく。

- 挿入モードで終わるコマンドでも、自動的にノーマルモードに復帰する
- 指定したノーマルモードコマンドを各行に対して実行する前に、カーソルをその行の先頭に移動する
  - `:%normal i//` は、カーソル位置を問わず先頭に追加するようになる

ノーマルコマンドは `:normal .` or `:normal @q` が最強:
詳細は後述する。

コマンドモードで `<C-d>` と打つと可能な候補が閲覧できる:
それ用のプラグインを入れてしまっているのでそんなに使わないかもしれないが、バニラVimを使う際には役に立つかもしれない。

コマンドモードで `<C-r><C-w>` とすると、モードに入る前のカーソル上の単語をコマンドに入力できる:
`<C-r><C-a>` とすると、いわゆるwordではなくWORDを入力できる。
覚えづらいがいつか役に立つかも？

`q:` でコマンドをVimライクに編集する:
便利である一方で、あまり使う機会は無いのかもしれない。
`q/` とすると検索コマンドを編集できるが、こちらのほうが複雑な正規表現などを入力したいときに便利になるかもしれない。
また、普通にコマンドラインモードに入った後に `<C-f>` とすると、途中からコマンド編集モードに切り替えられる。
ただし、これは自分の環境ではポップアップを出すプラグインのため、ちょっと使いづらいかもしれない。

コマンドラインでは `%` は現在編集中のファイル名:
`!{cmd}` でのみ有効？
有効なコンテキストがちょっとまだわかっていない。
ただし、拡張子だけを取り出したりもできるので `:h filename-modifiers` というヘルプも覚えておく。

バッファの内容を標準入力・標準出力に接続する:
`:read !{cmd}` と `:write {cmd}` のこと。
前者は「コマンドの出力をバッファに吐き出す」、後者は「標準入力としてバッファの内容を使用する」となる。
後者が場合によっては強力かも。
`:write !sh` とすると、バッファの各行をシェルに実行させられる。

外部コマンドを介してバッファの内容をフィルタリングする:
これはビジュアルモードと `:!{cmd}` というシェルコマンドの組合せ。
選択範囲を標準入力に渡しコマンドを実行、コマンドの出力でビジュアル範囲を上書きする。
「指定した `{cmd}` によって `[range]` がフィルタリングされる」とも考えられる。

`:bufdo` コマンド:
`:ls` で列挙されるすべてのバッファに対してExコマンドを実行できる。
おぼえておきたいが `:argdo` の方を理解してマスターしたい。

`:args` コマンド:
引数リストを出力するコマンド。
引数リストという概念から大事。
引数リストは、vimコマンドの起動時に引数として渡されたファイルのリストを表す。
`:args` コマンドはそれ単体だと引数リストの出力だが、引数を渡して実行すると、渡した引数で引数リストが再設定される。
基本的には、存在する複数のファイル名をglob形式で指定することになる。
もちろん、直接指定するのもあり。

また、シェルのようにバッククォートでの出力結果を渡すこともできる。

```
# .chaptersにファイル名が列挙されている場合、引数リストがいい感じに設定される
:args `cat .chapters`
```

argsコマンドを実行すると新たにファイルがバッファにオープンされるが、
すでに開かれたバッファを閉じる、ということにはならない。
ただ、引数リストはちゃんと更新されている（通常 `:ls` コマンドとは異なった内容となる）。
`:args ...` のあとに所望のファイル群に `:argdo` したりする。
`:argdo` の一番簡単な例は `:argdo write` でバッファを一括保存すること。

`:edit!` でバッファの内容を捨てファイルをディスクから読み直す:
リロードの手段としてちゃんと覚えておきたい。

`:qall!` と `:wall` コマンド:
見ての通りのコマンド。
全部に対して実行する、というのも危険な場合はあれど覚えておきたい。

`%:h` でアクティブなバッファのディレクトリ情報だけを取得する:
以下のようなコマンドモードのキーマップを用意すると `%%` で展開できるようになるっぽい。

```vim
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'
```

存在していないディレクトリにファイルを保存:
シェルのmkdirコマンドを使って、以下のようにする。
`!mkdir -p %:h` これは先程の知識も利用している。

`ea` と `gea` でいい感じに単語の末尾で挿入モードに入る:
`ge` は `e` の後ろ方向バージョンだが、 `gea` と暗記すると案外使えるかもしれない。

wordとWORDの定義を認識する:
wordは「英文字、数字、アンダースコアが連続したもの」
WORDは「非空白文字が連続したもの」
ピリオドとアポストロフィはwordとしてカウントされることも覚えておく。
大幅に移動したいときは `W` で移動するのもいいかもしれない。

テキストオブジェクトはモーションそのものではない:
しかしながら、モーションが適用できる場所ではテキストオブジェクトが適用できる。

`_` はブラックホールレジスタ:
`"_d{motion}` とすると、無名レジスタを汚さずに済む。

削除・ヤンク・プットコマンドはレジスタを使う:
`"ayiw` や `"ap` などがノーマルモードでの使い方。
Exコマンドでもレジスタは指定できる。
`:delete c` は、レジスタ `c` に現在のカーソル行をカットする。
`:put c` は、レジスタ `c` の内容をカーソル行の直下に貼り付ける。
`:yank c` も似たような感じになる。
Vimスクリプトを書く際には覚えておきたい。

`"` は無名レジスタ:
レジスタを指定しないと、この無名レジスタを使う。

`0` はヤンクレジスタ:
`y{motion}` という使い方がされると、またその時のみ、無名レジスタに加えて、ヤンクレジスタにも内容がコピーされる。
ヤンクレジスタは無名レジスタに比べて消えにくい、と言える。

`:reg {registers}` で指定したレジスタの内容を表示する:
一気に複数のレジスタを確認できる。
というより、引数なしだと（多分）設定されているすべてのレジスタが閲覧できる。

名前付きレジスタ:
小文字アルファベット1つ1つが名前付きレジスタのため、26種類存在することがわかる。
大文字アルファベットを使うと、指定したレジスタに「追記」される。

クリップボードレジスタは `+` or `*`:
厳密にはシステムごとに違うっぽいが、少なくとも自分が触ってきたMacOSとUbuntuに限っては `+` で問題なさそう。

Expressionレジスタ `=`:
これはちょっと使い方が特殊なので、実用例は後述。

その他のレジスタ（読み取り専用レジスタ）:
コマンドと検索が大事な気がする。

- `%`: 現在のファイルのファイル名
- `#`: 代替ファイルのファイル名？
- `.`: 直前に挿入されたテキスト
- `:`: 直前に実行されたExコマンド
- `/`: 直前に検索された検索パターン

レジスタを使ってビジュルな選択範囲を置換:
ビジュアルモードで `p` とすると、指定されたレジスタの内容で選択範囲が置き換えられる。
レジスタにはビジュアル範囲が入ることになる。
覚えておくと割と効率的に使えるかも。

**挿入モードで `<C-r>` と入力してからレジスタを指定する:**
今回の復習で最重要の一つの手法。
`<C-r>"` とすると通常のヤンクと同じだが、カーソルの後に挿入されるというのが明白なのが利点だったりする。
`<C-r>=` としてExpressionレジスタを使うと色々な応用が期待できる。
Vim scriptは色々標準装備しておきたい。

**マクロの記録と実行:**
マクロも今回を機に熟練度を上げたい。
ノーマルモードで `q{register}` と入力するとマクロの記録が開始され、再度 `q` とタイプするとそこで終了する。
シーケンスはレジスタに入るため `:reg {register}` で確認できる。
そして実行は、ノーマルモードで `@{register}` とすればよい。
また、 `@@` とすると、直前に呼び出されたマクロを繰り返す。

マクロの考え方のコツ。

> マクロを「直列」に実行するテクニックは脆い。
> クリスマスツリー用の安い電球と同じで、簡単に壊れてしまう。
> マクロを「並列」に実行するテクニックはもっとエラーに強い。

> マクロを記録するというのは、仕事の一単位を行うようにロボットをプログラミングするようなものだ。

> マクロを並列に実行するのは、ベルトコンベアを全く使わずにやるようなものだ。
> ベルトコンベアを使うのではなく、たくさんのロボットを用意するのだ。
> これらのロボットはすべて、ある1つのシンプルな作業だけを行うようにプログラムされている。
> 各ロボットには、するべき仕事が1つだけ割り当てられる。
> うまくいったら...それはよかった。
> 失敗したら...まあ、問題はない。

> 黄金率: マクロを記録するときには、すべてのコマンドは必ず繰り返し可能であるようにしよう。

- カーソルの位置の正規化
  - `^$0` といったモーションを使うと、どの列にいてもまずはカーソル位置を正規化できる
- 繰り返し可能なモーションでターゲットを撃破しよう
- モーションに失敗したら処理は中断する
  - 安全装置！

最後が重要（※デフォルトでは、モーションが失敗すると、Vimはビープ音を鳴らしてくれる）。
マクロがその段階でストップしてくれる、というのはうまく利用できる。

`10@a` とするとマクロは10回実行される:
この数字が適当に決められても問題のないようにマクロを組むと良い。
冪等性。
特に、アットマークと同じ位置にある `22` という数字は試しに使ってみる。
同じ理由で、マクロも普段遣いは `q` レジスタを使えば良さそう。

**`:normal @a` でマクロを並列実行する:**
これを行指向のビジュアルモードで行うと、選択範囲の各行に対してマクロを実行するようにVimに伝える。
というか、マクロもノーマルコマンドの一種なんだ、ということを認識するほうが大事かもしれない。

※並列実行は強烈だが、直列のほうが有効な場合もありうる。

（所感）1行に集中できるのであればとりあえずは気楽なので、まずは1行に対するマクロを考えてみる。

`qA` のように大文字でレジスタを指定するとマクロを追記できる:
レジスタの使い方を考えると納得できる。

`:argdo normal @a` で複数のファイルにマクロを適用する
かなり応用的な気がするので、マクロに大分自信がついてからでいい気がする。

イテレータを評価してリスト中の要素に番号をつける:
最初に `:let i = 1` として、以降マクロ中で `:let i += 1` とし、挿入モードで `<C-r>=i` とすると、いい感じにインクリメントしつつ値をバッファに入力できる。
というより、マクロ中ではExコマンドの実行や、挿入モードからEscで抜ける、などもできることに注目したい。
また、範囲指定して `:normal @q` として並列実行しても、これも結局はマクロは一つずつ上から実行されるので、
ちゃんと値はインクリメントされる。
各行の行頭に数値付きのマークをつけるのは、マクロ典型と言えるかもしれない。

マクロの内容をプレーンテキストのように編集する:
基本的には、マクロはレジスタに文字列を貼り付けたようなものなので、それを操作すれば良い。
マクロを吐き出すには `:put q` のようなputコマンドが便利。
これを編集して、また再びレジスタにヤンクすれば良い。
ヤンクするときは `0"qy$` のようにすると、行末の改行は含めないので覚えておきたい。
※とはいえ、マクロ内には特殊文字が含まれがちなので、単純にappendする場合は `qQ` とかのほうが良さそう。

Vimのレジスタは、テキストの文字列を保持するコンテナに過ぎない:
以下のように、関数を使った汎用的なマクロも組めるかもしれない。
`:let @a=substitute(@a, '\~', 'vU', 'g')`
Vim scriptの関数は `:h function-list` で調べられる。
