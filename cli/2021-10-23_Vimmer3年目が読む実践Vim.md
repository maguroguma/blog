[実践Vim](https://tatsu-zine.com/books/practical-vim)の復習。

新卒でVimを覚えて、VSCodeVim入りのVSCodeに一時期浮気して、
NeoVimに引っ越し＆[coc.nvim](https://github.com/neoclide/coc.nvim)の存在を知ってからはNeoVimにどっぷり。
いよいよ3年ぐらい経とうとしているものの、まだまだ実践できていなものも多いので、Vimの運用を見直すべく復習してみる。

完全に自分用だけど、もしかしたら思考がシンクロしがちな人がいたら刺さる部分があるかも。

雑に以下のカテゴリに分けてみた。

- レジスタ
- マクロ
- Exコマンド
- パターン、マッチ、vimgrep
- その他

---

## レジスタ

レジスタは単なるテキストの置き場所ではあるものの、他の機能やコマンドと併用することで柔軟な操作が可能になる。

### レジスタの種類

#### 名前付きレジスタ

小文字アルファベット1つ1つが名前付きレジスタのため、26種類存在する。
大文字アルファベットを使うと、指定したレジスタに「追記」される。

#### `"` は無名レジスタ

レジスタを指定しないと、この無名レジスタを使う。

#### `0` はヤンクレジスタ

`y{motion}` という使い方がされると、またその時のみ、無名レジスタに加えて、ヤンクレジスタにも内容がコピーされる。
ヤンクレジスタは無名レジスタに比べて変化しにくい、と言える。

#### クリップボードレジスタは `+` or `*`

厳密にはシステムごとに違うっぽいが、少なくとも自分が触ってきたMacOSとUbuntuに限っては `+` で問題なさそう。

#### `_` はブラックホールレジスタ

`/dev/null` みたいなイメージ。
`"_d{motion}` とすると、無名レジスタを汚さずに済む。

#### Expressionレジスタ `=`

これはちょっと使い方が特殊なので、実用例は後述。

#### その他のレジスタ（読み取り専用レジスタ）

特に検索パターンを覚えておくと便利。

- `%`: 現在のファイルのファイル名
- `#`: 代替ファイルのファイル名？
- `.`: 直前に挿入されたテキスト
- `:`: 直前に実行されたExコマンド
- `/`: 直前に検索された検索パターン

### レジスタの使い方

#### コマンドモードもしくは挿入モードで `<C-r>` と入力してからレジスタを指定する

**今回の復習で最重要な手法の1つ。**

`<C-r>"` とすると通常のヤンクと同じだが、カーソルの後に挿入されるというのが明白なのが利点だったりする。
ヤンクしたものを貼り付けたい場合は、タイプのしやすさは `<C-r>0` のほうがいいかも。

#### Expressionレジスタの呼び出し方

`=` はExpressionレジスタで、 `<C-r>=` とすると挿入モードからプロンプトが出せる。
この間は「コマンドラインモード」に分類されるらしい。
Enterで入力を確定させると、バッファに結果が挿入される。

#### 削除・ヤンク・プットコマンドはレジスタを使う

`"ayiw` や `"ap` などがノーマルモードでの使い方。
Exコマンドでもレジスタは指定できる。

`:delete c` は、レジスタ `c` に現在のカーソル行をカットする。  
`:put c` は、レジスタ `c` の内容をカーソル行の直下に貼り付ける。  
`:yank c` も似たような感じになる。  

Vimスクリプトを書く際には覚えておきたい。

#### レジスタを使ってビジュアルな選択範囲を置換

ビジュアルモードで `p` とすると、指定されたレジスタの内容で選択範囲が置き換えられる。
レジスタにはビジュアル範囲が入ることになる。
覚えておくと割と効率的に使えるかも。

#### レジスタの内容を確認する方法

`:reg {registers}` で指定したレジスタの内容を表示する。
引数なしだと、設定されているすべてのレジスタが閲覧できる。

#### 通常ビジュアルモード、レジスタ、パターン検索の併せ技から学ぶ

`"uyi[/\V<C-r>u<CR>` こうすることで、レジスタuにヤンクしてその内容でパターン検索、という形にできる。

レジスタを介するこの手法は、汎用性が高そう。

#### 置換文字列でVim script式評価を使う

まず、**Vim scriptでは、レジスタの内容を `@{register}` で参照できる。**

置換文字列においては `\=` のあとにVim scriptを書くことでそれが評価される。
`:%s//\=@0/g` は「直前の検索パターンをヤンクレジスタの内容で置き換えろ」という命令になる。

#### レジスタをVim scriptで書き換える

`:let @a = 'Practical Vim'` はレジスタaを設定している。

---

## マクロ

マクロもあまり使ってこなかったが、「レジスタに記録したノーマルモードのコマンドを再生する」と考えると、割とフランクに使えるかもしれない。
とにかく数をこなさないとこういうのはできるようにならないので、ちょっとでも繰り返しが多そうなタスクに出会ったら意識したい。

### マクロの記録と実行

ノーマルモードで `q{register}` と入力するとマクロの記録が開始され、再度 `q` とタイプするとそこで終了する。
シーケンスはレジスタに入るため `:reg {register}` で確認できる。

そして実行は、ノーマルモードで `@{register}` とすればよい。
また、 `@@` とすると、直前に呼び出されたマクロを繰り返す。

以下はマクロの考え方のコツ（書籍より引用）。

> マクロを「直列」に実行するテクニックは脆い。
> クリスマスツリー用の安い電球と同じで、簡単に壊れてしまう。
> マクロを「並列」に実行するテクニックはもっとエラーに強い。

> マクロを記録するというのは、仕事の一単位を行うようにロボットをプログラミングするようなものだ。

> マクロを並列に実行するのは、ベルトコンベアを全く使わずにやるようなものだ。
> ベルトコンベアを使うのではなく、たくさんのロボットを用意するのだ。
> これらのロボットはすべて、ある1つのシンプルな作業だけを行うようにプログラムされている。
> 各ロボットには、するべき仕事が1つだけ割り当てられる。
> うまくいったら...それはよかった。
> 失敗したら...まあ、問題はない。

### 黄金律

これも書籍からそのまま引用。

> マクロを記録するときには、すべてのコマンドは必ず繰り返し可能であるようにしよう。

以下の3点もとても重要。

- カーソルの位置の正規化
  - `^$0` といったモーションを使うと、どの列にいてもまずはカーソル位置を正規化できる
- 繰り返し可能なモーションでターゲットを撃破しよう
- モーションに失敗したら処理は中断する
  - 安全装置！

最後はうまく利用するととても強力（※デフォルトでは、モーションが失敗すると、Vimはビープ音を鳴らしてくれる）。
マクロがその段階でストップしてくれる、というのはうまく利用できる。

`10@a` とするとマクロは10回実行される:
この数字が適当に決められても問題のないようにマクロを組むと良い。
冪等性は大事。
特に、アットマークと同じ位置にある `22` という数字は試しに使ってみる。
同じ理由で、マクロも普段使いする際は `q` レジスタを使えば良さそう。

### `:normal @a` でマクロを並列実行する

これを行指向のビジュアルモードで行うと、選択範囲の各行に対してマクロを実行するようにVimに伝える。
というか、「マクロもノーマルコマンドの一種である」ということを認識するほうが大事かもしれない。

並列実行は強烈だが、直列のほうが有効な場合もありうる。
とはいえ、1行に対する処理に集中できるのであればとりあえずは気楽なので、まずは1行に対するマクロを考えてみる。

### `qA` のように大文字でレジスタを指定するとマクロを追記できる

レジスタの使い方を考えると納得できる。

### `:argdo normal @a` で複数のファイルにマクロを適用する

かなり応用的な気がするので、マクロに大分自信がついてからでいい気がする。

### イテレータを評価してリスト中の要素に番号をつける

各行の行頭に数値付きのマークをつけるのは、マクロ典型と言えるかもしれない。

最初に `:let i = 1` として、以降マクロ中で `:let i += 1` とし、挿入モードで `<C-r>=i` とすると、いい感じにインクリメントしつつ値をバッファに入力できる。

というより、マクロ中ではExコマンドの実行や、挿入モードからEscで抜ける、などもできることに注目したい。
また、範囲指定して `:normal @q` として並列実行しても、これも結局はマクロは一つずつ上から実行されるので、ちゃんと値はインクリメントされる。

### マクロの内容をプレーンテキストのように編集する

基本的には、マクロはレジスタに文字列を貼り付けたようなものなので、それを操作すれば良い。

マクロを吐き出すには `:put q` のようなputコマンドが便利。
これを編集して、また再びレジスタにヤンクすれば良い。
ヤンクするときは `0"qy$` のようにすると、行末の改行は含めないので覚えておきたい。

とはいえ、マクロ内には特殊文字が含まれがちなので、単純にappendする場合は `qQ` とかのほうが良さそう。

### Vimのレジスタは、テキストの文字列を保持するコンテナに過ぎない

以下のように、関数を使った汎用的なマクロも組めるかもしれない。

```vim
:let @a=substitute(@a, '\~', 'vU', 'g')
```

Vim scriptの関数は `:h function-list` で調べられる。

---

## Exコマンド

プラグインのコマンドはよく使っていたが、Vim組み込みのコマンドはあまり使いこなせていなかった気がする。
`argdo` などの複数ファイルに渡って変更を加える操作は状況によっては強力に使えると思うので、一通り頭に入れておきたい。
組み込みのコマンドを頭に入れておくことは、Vim scriptで込み入ったことをしたいときにも活きる、と思う。

### Vimのコマンドラインモード（Exコマンド）

「どういうときにコマンドラインモードになるのか」をまずは理解する。

コロンを打ったとき、スラッシュで検索するとき、Expressionレジスタにアクセスするときは、すべてコマンドラインモードとなる。

### Exコマンドを、アドレスで行範囲を指定する

`:{start},{end}` で指定できる。

基本は行番号を指定することになるが、いくつか特殊なものがある。

- `:/<html>/+1,/<\/html>/-1`: 合致するタグに挟まれる部分を指定する、オフセットの構文を利用している
- `%`: ファイル全体を示すが、これは `:1,$` と等価であることを意識したい

### copyコマンド

`:6copy.` とすると、「6行目を現在行にコピー」となる

ビジュアルモードで範囲指定してから `:$` とタイプすると、選択範囲が末尾に貼られる。
覚えておくと、案外普段から使えるかもしれない。

`:t` でも等価らしいので、手打ちするときはこちらのほうが早い。
また、レジスタを介さないので、クリーンでもある。

### moveコマンド

`:move` もしくは `:m` でよい。

範囲や移動先の指定方法はcopyと同じ。

### Exコマンドの繰り返し

`@:` で前回のExコマンドを繰り返せる。

これはマクロの一種と考えて良さそう。

### normalコマンド

normalコマンドが何を指すのか、というのは個人的によく忘れるので、具体例で覚えてしまうのが良い。

`:'<'>normal .` は「選択範囲にドットコマンド」となる。  
`:%normal A;` は「ファイルのすべての行の行末にセミコロンを追加」となる。  

normalコマンドのルールは覚えておく。

- 挿入モードで終わるコマンドでも、自動的にノーマルモードに復帰する
- 指定したノーマルモードコマンドを各行に対して実行する前に、カーソルをその行の先頭に移動する
  - `:%normal i//` は、カーソル位置を問わず先頭に追加するようになる

### ノーマルコマンドは `:normal .` or `:normal @q` が最強

逆に言うと、これらのノーマルコマンドが適用できるように、ドットコマンドやマクロを組むことを考えるように意識したい。

### コマンドモードで `<C-d>` と打つと可能な候補が閲覧できる

それ用のプラグインを入れてしまっているのでそんなに使わないかもしれないが、バニラなVimを使う際には役に立つかもしれない。

### コマンドモードで `<C-r><C-w>` とすると、モードに入る前のカーソル上の単語をコマンドに入力できる

`<C-r><C-a>` とすると、いわゆるwordではなくWORDを入力できる。
覚えづらいがいつか役に立つかも？

### `q:` でコマンドをVimライクに編集する

便利である一方で、案外あまり使う機会は無いのかもしれない。

`q/` とすると検索コマンドを編集できるが、こちらのほうが複雑な正規表現などを入力したいときに便利になるかもしれない。

また、普通にコマンドラインモードに入った後に `<C-f>` とすると、途中からコマンド編集モードに切り替えられる。
ただし、これは自分の環境ではポップアップを出すプラグインのため、ちょっと使いづらいかもしれない。

### コマンドラインでは `%` は現在編集中のファイル名

拡張子だけを取り出したりもできるので `:h filename-modifiers` というヘルプも覚えておく。

### `%:h` でアクティブなバッファのディレクトリ情報だけを取得する

以下のようなコマンドモードのキーマップを用意すると `%%` で展開できるようになるっぽい。

```vim
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'
```

### バッファの内容を標準入力・標準出力に接続する

`:read !{cmd}` と `:write {cmd}` のこと。

前者は「コマンドの出力をバッファに吐き出す」、後者は「標準入力としてバッファの内容を使用する」となる。

後者が場合によっては強力かも。
`:write !sh` とすると、バッファの各行をシェルに実行させられる。

readとwriteの目的語がなんなのかを意識しないと、わからなくなってしまう。
両者とも目的語はシェルコマンドであることに注意する（シェルコマンドの結果をreadする、シェルコマンドに書き込む（≒標準入力に渡す））。

### 外部コマンドを介してバッファの内容をフィルタリングする

これはビジュアルモードと `:!{cmd}` というシェルコマンドの組合せで行われる。

選択範囲を標準入力に渡しコマンドを実行、コマンドの出力でビジュアル範囲を上書きする。
「指定した `{cmd}` によって `[range]` がフィルタリングされる」とも考えられる。

### `:bufdo` コマンド

`:ls` で列挙されるすべてのバッファに対してExコマンドを実行できる。
おぼえておきたいが `:argdo` の方を理解してマスターしたい。

### `:args` コマンド

引数リストを出力するコマンド。

引数リストという概念から大事。
引数リストは、vimコマンドの起動時に引数として渡されたファイルのリストを表す。

`:args` コマンドはそれ単体だと引数リストの出力だが、引数を渡して実行すると、渡した引数で引数リストが再設定される。
基本的には、存在する複数のファイル名をglob形式で指定することになる。
もちろん、直接指定するのもあり。

また、シェルのようにバッククォートでの出力結果を渡すこともできる。

```vim
" .chaptersにファイル名が列挙されている場合、引数リストがいい感じに設定される
:args `cat .chapters`
```

argsコマンドを実行すると新たにファイルがバッファにオープンされるが、
すでに開かれたバッファを閉じる、ということにはならない。
ただ、引数リストはちゃんと更新されている（通常 `:ls` コマンドとは異なった内容となる）。

`:args ...` のあとに所望のファイル群に `:argdo` したりする。
`:argdo` の一番簡単な例は `:argdo write` でバッファを一括保存すること。

### `:edit!` でバッファの内容を捨てファイルをディスクから読み直す

リロードの手段としてちゃんと覚えておきたい。

### `:qall!` と `:wall` コマンド

見ての通りのコマンド。
全部に対して実行する、というのも危険な場合はあれど覚えておきたい。

---

## パターン、マッチ、vimgrep

まずは、「パターン」と「マッチ」の意味を正しく把握するところから。

> **パターン**といったら、それは検索フィールドに入力する正規表現（もしくはリテラルなテキスト）のことだ。
> **マッチ**と言ったら、それはドキュメント内で強調表示される何らかのテキストのことだ。

続いて、vimgrepはVimの検索パターンを流用できることの意味が大きい。
grepperなど非同期で便利なプラグインもあるが、検索がしやすいvimgrepでquickfixリストを更新できるなど、覚えておいて損はないはず。

### very magic検索 `\v` を使うとすべての特殊記号に関する規則を正規化できる

`\v` すると、アンダースコア、大文字小文字のアルファベット、数字を除く、すべての文字が特殊な意味を持つことになる。

普通に正規表現で `()` などを使おうとすると、すべてエスケープする必要が合って面倒だが、
`\v` とすることで正規表現を意図したパターンが書きやすくなる。

### nomagic検索 `\V` を使う

very magicの真逆で、こうすると素直に入力した内容そのままでのテキスト検索が出来る。

バックスラッシュ以外は普通の意味を持つことになる。
一般的には、**「正規表現を検索したければ `\v` パターンスイッチを使い、テキストそのものを検索したければ `\V` リテラルスイッチを使う。」**

### 単語境界デリミタを覚える

たとえば `/\v<the>` とすることで their などの単語をヒットしないようにすることができる。
very magicを使わないと `/\<the\>` としなければならないことに注意する。

### マッチ境界 `\zs, \ze` を理解する

これは例で理解するほうが良い。

パターンを `/Practical Vim` とすると素直に「Practical Vim」が強調表示される。
`/Practical \zsVim` とすると「Practical Vim」というフレーズのVimは強調表示されるが、Vim単体のものは強調表示されない。

他にも、ダブルクォートに囲まれるもののみマッチさせようとすると、以下のようになる。

```vim
/\v"\zs[^""]+\ze"
```

マッチからは除外されていても、パターンのなかでは、ダブルクォートは重要な要素であることに注意が必要。

### レジスタ中の文字列をエスケープする

`escape(@u, '/\')` とすると「レジスタu中のスラッシュ・バックスラッシュをエスケープする」という具合。

### 検索のマッチの末尾にカーソルをオフセットする

**これは何気にとても重要だと思う。**

`/vim/e` のように、 `/e` を付け加えると、ジャンプする先がマッチの末尾になる。

これによって、 `a` コマンドから単語に数文字付け加える、ということが可能になる。
これはドットコマンドとうまく組合せられるかもしれない。

この類のものは `:h search-offset` で調べられる（検索オフセット）。
あとからこれが必要と気づいたときには、 `//e` とすることで前回のパターンを再利用できる。

### `f` コマンドは大文字にめがけて使うといいかもしれない

fコマンドはもっともっと使いこなしたい。
大文字の存在感は大きいので、使い方として覚えておく。

### `q/` とすることによってコマンドラインウィンドウを表示できる

`q:` と同じ要領で編集ができる。
検索コマンドは複雑なので、複雑な検索がやりたいときは思い出すといいかもしれない。

### 現在のビジュアルな選択範囲の検索

以下のVim scriptで可能なようだが、応用が効きそうなのでそのまま引用しておく。

```vim
" xnoremapは「ビジュアルモードには適用されるが、選択モードでは適用されない」というもの
xnoremap * :<C-u>call <SID>VSetSearch()<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call <SID>VSetSearch()<CR>?<C-R>=@/<CR><CR>

" /レジスタの内容を書き換えている
" gvは直前の選択範囲を再利用する
function! s:VSetSearch()
  let temp = @s
  norm! gv"sy
  let @/ = '/V' . substitute(escape(@s, '/\'), '\n', '\\n', 'g')
  let @s = temp
endfunction
```

### 直前の検索パターンを流用する

無意識でやっていることが多いが、改めて再認識する。

> 置換コマンドが2つのステップで構成されているところがポイントだ。
> つまり、パターンを組み立てることと、適切な置換文字列を考えること。
> この方法を使えば、いつだって、置換コマンドをこれら2つの作業に分割できる。

visual-starなんかも有効活用できる。
まずvisual-starでパターンを決めてから（マッチを確認し）、 `:%s//.../gc` とすればよい。

### 部分マッチを使ってCSVのフィールドを入れ替える

正規表現パターンにおけるマッチのキャプチャの例として知っておく。

```
/\v^([^,]*),([^,]*),([^,]*)$
:%s//\3,\2,\1
```

`\x` の部分が、部分マッチの参照となっている。
Vim scriptの関数だと `submatch(x)` が同等っぽい。

### 複数のファイルに置換コマンドを実行する

`:argdo %s//Practical/g` のようにする。

パターンにマッチするものがなかったときはエラーを吐くが、これを抑制したい場合は、
置換コマンドの部分を `%s//Practical/ge` のように `e` フラグを指定すれば良い。

### ターゲットのパターンを含んでいるファイルのリストを作成する

vimgrepは同期的であまり高速ではないものの、うまく使えば便利に活用できる例。

Vimに組み込みの検索エンジンを使うので、全く同じパターンを流用できるのがいいところ。
`:vimgrep /<C-r>// **/*.txt` のようにすると前回の検索パターンでvimgrepできて、ファイルがオープンされる。

`./**/*.{ext}` のようにすれば、再帰的にすべてのディレクトリを舐めることになる。

### vimgrepが返す各マッチはquickfixリストに記録される

vimgrepの後に `:copen` としてquickfixリストをブラウズできる。

Qargsという、quickfixリストの内容で引数リストを更新するコマンドを追加するプラグインが、実践Vimの作者から提供されている。
これを利用すると、以下のような一連のコマンドが考えられる。

```vim
" \zeまでがマッチするようなパターン
/Pragmatic\ze Vim
:vimgrep /<C-r>// **/*.txt
:Qargs
:argdo %s//Practical/g
" updateコマンドは、変更が合ったファイルのみ保存される
:argdo update
```

また、最後の3つのコマンドはバーティカルバーによって1つにまとめられる。

```vim
:Qargs | argdo %s//Practical/g | update
```

**Vimにおけるバーティカルバーは、Unixのシェルにおけるセミコロンと同等。**
Vim scriptのワンライナーを書くことは少ないかもしれないが、覚えておきたい。

### quickfixリスト

errorformatと呼ばれるものに適合するように出力をパースすることで、quickfixリストが作れるっぽい。

> Vimのquickfixリストは、外部ツールをVimで行う作業に組み込むための核となる機能だ。
> これは非常にシンプルに、エラーがあると報告されたファイルの「ファイル名・行番号・桁番号（オプション）・メッセージ」で構成されるアドレス群を管理するものだ。

### grep/vimgrepなどを使ってプロジェクト全体を検索する

> vimgrepコマンドなら、Vimにネイティブな検索エンジンを使って複数ファイルからパターンを検索できることを見てみよう。
> これには代償もある。
> つまり、vimgrepは他の専用プログラムほどには高速ではない。

### Vimの `:grep` コマンドは外部プログラムgrepのラッパー

`:grep Waldo *` は `grep -n Waldo *` を実行しているのと同じ。
また、 `:grep` コマンドもquickfixリストを作る。

### vimgrepコマンド

`:vim[grep][!] /{pattern}/[g][j] {file} ...`

gフラグをつけると、1行の複数のマッチを捉える。
jフラグをつけると、最初のマッチへのジャンプをキャンセルできる。
quickfixリストが作りたいだけならつけたほうが良さそう。

file引数は必須。
ファイル名、ワイルドカード、バッククォート式、これらの組合せたものなど、argsコマンドと同じ引数が指定可能。

- `*` ワイルドカードはディレクトリ内のすべてのファイルにマッチする。
- `**` ワイルドカードは、指定したディレクトリまたはそのサブディレクトリにあるすべてのファイルにマッチする。
- `##` は引数リストに含まれている各ファイルの名前に展開される。

vimgrepの利点は現在のバッファのマッチを確認することで、パターンを正しく組み立てやすいこと。

`:vim /<C-r>// **` とすると現在のパターンで検索してくれる。

**注意点として、パターンを空にするのはダメ、ということ。**
`<C-r>/` でレジスタから実際のパターン文字列を引っ張ってくる必要がある。

### グローバルコマンド

> `:global` コマンドは、**Exコマンド**のパワーとVimの**パターンマッチ**機能とを結合する。
> これを使って、指定したパターンにマッチする各行に、Exコマンドを実行できる。
> ドットの公式やマクロと並んで、 `:global` コマンドは、繰り返し作業を効率的に行うための、Vimの強力なツールなのだ。

`[range] global[!] /{pattern}/ [cmd]`

rangeを与えないデフォルトでは、ファイル全体 `%` となる。
他のExコマンド `:delete, :substitute, :normal` と大きく異なり、ほとんどのデフォルトの範囲はカーソル行 `.` である。

patternはVimの検索機構なので、空にしておくと現在の検索パターンを自動的に使ってくれる。
その場合は `//` とだけ入力すれば良い。

cmdはglobal以外のコマンドを指定できる。
デフォルトは `:print` コマンドが使われるので、表示されるだけで何もしない。
ドキュメント中のテキストを操作するExコマンドを指定すると便利なことが多い。

`:global!` もしくは `:vglobal` は、パターンマッチ「していない」行に作用する。

#### レジスタにTODOアイテムを収集する

yankコマンドを併用して、指定したレジスタにTODOの行をヤンクする。
`:argdo` とさらに併用すると、複数ファイルからかき集めることもできる。

```vim
" 空のマクロを記憶させることでレジスタを消去する
qaq
:g/TODO/yank A
```

#### Vim組み込みの `:sort` コマンドを使う

範囲指定すれば部分的に使える場面は多そう。
ただ、コードフォーマッタに任せたくなることが多そう。

#### globalコマンドに渡すExコマンドも範囲を受け取れることを理解する

**Exコマンドは常にそれ自体が範囲を受け取れることを思い出す。**

`:g/{pattern}/[range][cmd]`

以下のコマンドは、CSSの波括弧内のみをsortするglobalコマンドの応用（難しい）。

`:g/{/ .+1,/}/-1 sort`

sortの範囲がちょっと難しいが、「現在行（≒各 `/{/` のマッチ行）の1つ下の行から、 `/}/` のマッチ行の1つ上の行まで」という意味になる。

---

## その他

細々としたトピックだが、かゆいところに手が届きそうなテクニックなど。

### 単なる単語消去の際は `daw` がよい

ドットコマンドとの相性も良い。

### 挿入ノーマルモード

挿入モード時に `<C-o>` をタイプするとノーマルモードに遷移するが、そこで何かノーマルコマンドを打つとすぐに挿入モードに戻る。
例えば、 `<C-o>zz` とすると、挿入モードのまま画面を中央に戻すことができる。

普段のコマンドとしては使わないかもしれないが、複合的なコマンドをキーマップするなどすると、うまく適合するケースがあるかもしれない。

### 文字コードを使って特殊文字を入力

挿入モードで `<C-v>` とし、その後に文字コードを指定する（みんな文字コードって覚えてるの。。？）

### ダイグラフによって特殊文字を挿入

挿入モードでは `<C-k>{char1}{char2}` とする。
ダイグラフのほうが直感的なため、覚えておくといいかも。

### 置換モード

ノーマルモードで `R` とタイプすると、置換モードに遷移する。

そもそもこのモードは認識したことがなかったので、ステータスバーが見慣れない色に変化するな、とか思った。
そのままタイプすると、カーソル位置の単語が入力内容で置換され続ける。
使いそうだけど、あまり使いそうにないか。。

### ビジュアルモードの再選択

ノーマルモードで `<gv>` とすると、直前に選択した範囲を再選択した状態でビジュアルモードに入れる。

マクロとかで繰り返し作業をする際には出番が多くありそう。

### ビジュアルモードの始点・終点をトグルする

ビジュアルモードで `o` とタイプすると、始点と終点が入れ替わるので、微調整に便利。

通常・行指向・ブロック指向いずれでも直感的な挙動となる。

### `gu` と `gU`

それぞれ小文字化と大文字化。

ドットコマンドを便利に使うためには覚えておきたい。

### `ea` と `gea` でいい感じに単語の末尾で挿入モードに入る

`ge` は `e` の後ろ方向バージョンだが、 `gea` と暗記すると案外使えるかもしれない。

### wordとWORDの定義を認識する

- wordは「英文字、数字、アンダースコアが連続したもの」
- WORDは「非空白文字が連続したもの」

ピリオドとアポストロフィはwordとしてカウントされることも覚えておく。
大幅に移動したいときは `W` で移動するのもいいかもしれない。

### テキストオブジェクトはモーションそのものではない

しかしながら、モーションが適用できる場所ではテキストオブジェクトが適用できる。

### 存在していないディレクトリにファイルを保存

シェルのmkdirコマンドを使って、以下のようにする。
`!mkdir -p %:h` これは先程の知識も利用している。

---

以上。
なんか思ったよりも膨れてしまった。
