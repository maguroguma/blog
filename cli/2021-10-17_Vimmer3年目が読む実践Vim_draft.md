新卒でVimを覚えて、VSCodeVim入りのVSCodeに一時期浮気して、NeoVimに引っ越し＋cocnvimを覚えてからはNeoVimにどっぷり。
いよいよ3年ぐらい経とうとしているので、まだ実践できていなものを列挙してみる。

完全に自分用だけど、もしかしたら思考がシンクロしがちな人がいたら刺さる部分があるかも。

---

単なる単語消去の際は `daw` がよい。
ドットコマンドとの相性も良い。

挿入ノーマルモード:
挿入モード時に `<C-o>` をタイプするとノーマルモードに遷移するが、そこで何かノーマルコマンドを打つとすぐに挿入モードに戻る。
`<C-o>zz` とすると、挿入モードのまま画面を中央に戻すことができる。
もしかしたら、他の応用を `imap` すると便利かもしれない。

挿入モードから抜けないでレジスタから貼り付け:
挿入モード時に `<C-r>` からレジスタを指定すると、そのレジスタに登録されているものがバッファに入力される。
`<C-r><C-p>` としてからレジスタを指定すると、意図しないインデントなどを防いで、そのままが正しく入力される。
`0` は直前のyankした内容を保存しているらしく、 `<C-r>0` で挿入モードのままヤンクしたテキストを貼り付けることができる。

Expressionレジスタ:
`=` はExpressionレジスタで、 `<C-r>=` とすると挿入モードからプロンプトが出せる。
この間は「コマンドラインモード」に分類されるらしい。
Enterで入力を確定させると、バッファに結果が挿入される。

文字コードを使って特殊文字を入力:
挿入モードで `<C-v>` とし、その後に文字コードを指定する。
みんな文字コードって覚えてるの。。？

ダイグラフによって特殊文字を挿入:
挿入モードでは `<C-k>{char1}{char2}` とする。
ダイグラフのほうが直感的なため、覚えておくといいかも。

置換モード:
ノーマルモードで `R` とタイプすると、置換モードに遷移する。
そもそもこのモードは認識したことがなかったので、見慣れない色にステータスバーが変化するな、と思った。
そのままタイプすると、カーソル位置の単語が入力内容で置換され続ける。
使いそうだけど、あんま使わないか。。

ビジュアルモードの再選択:
ノーマルモードで `<gv>` とすると、直前に選択した範囲を再選択した状態でビジュアルモードに入れる。
覚えておくと、地味に効率化できるかも。

ビジュアルモードの始点・終点をトグルする:
ビジュアルモードで `o` とタイプすると、始点と終点が入れ替わるので、微調整に便利。
通常・行指向・ブロック指向いずれでも直感的な挙動となる。

`gu` と `gU`:
それぞれ小文字化と大文字化。
ドットコマンドを便利に使うためには覚えておきたい。

Vimのコマンドラインモード（Exコマンド）:
何がコマンドラインモード化を理解しておきたい。
コロンを打ったとき、スラッシュで検索するとき、Expressionレジスタにアクセスするときは、すべてコマンドラインモードとなる。

Exコマンドを、アドレスで行範囲を指定する:
`:{start},{end}` で指定できる。
基本は行番号を指定することになるが、いくつか特殊なものがある。

- `:/<html>/+1,/<\/html>/-1`: 合致するタグに挟まれる部分を指定する、オフセットの構文を利用している
- `%`: ファイル全体を示すが、これは `:1,$` と等価であることを意識したい

copyコマンド:
`:6copy.` とすると、「6行目を現在行にコピー」となる
ビジュアルモードで範囲指定してから `:$` とタイプすると、選択範囲が末尾に貼られる。
覚えておくと、案外普段から使えるかもしれない。
`:t` でも等価らしいので、手打ちするときはこちらのほうが早い。
また、レジスタを介さないので、クリーンでもある。

moveコマンド:
`:move` もしくは `:m` でよい。
範囲や移動先の指定方法はcopyと同じ。

Exコマンドの繰り返し:
`@:` で前回のExコマンドを繰り返せる。
単体では覚えにくいので、何らかと関連付けて覚えたい。

normalコマンド:
normalコマンドというと何を指すのか覚えにくいので、具体例で覚えてしまうのが良い。
`:'<'>normal .` は「選択範囲にドットコマンド」となる。
`:%normal A;` は「ファイルのすべての行の行末にセミコロンを追加」となる。
normalコマンドのルールは覚えておく。

- 挿入モードで終わるコマンドでも、自動的にノーマルモードに復帰する
- 指定したノーマルモードコマンドを各行に対して実行する前に、カーソルをその行の先頭に移動する
  - `:%normal i//` は、カーソル位置を問わず先頭に追加するようになる

ノーマルコマンドは `:normal .` or `:normal @q` が最強:
詳細は後述する。

コマンドモードで `<C-d>` と打つと可能な候補が閲覧できる:
それ用のプラグインを入れてしまっているのでそんなに使わないかもしれないが、バニラVimを使う際には役に立つかもしれない。

コマンドモードで `<C-r><C-w>` とすると、モードに入る前のカーソル上の単語をコマンドに入力できる:
`<C-r><C-a>` とすると、いわゆるwordではなくWORDを入力できる。
覚えづらいがいつか役に立つかも？

`q:` でコマンドをVimライクに編集する:
便利である一方で、あまり使う機会は無いのかもしれない。
`q/` とすると検索コマンドを編集できるが、こちらのほうが複雑な正規表現などを入力したいときに便利になるかもしれない。
また、普通にコマンドラインモードに入った後に `<C-f>` とすると、途中からコマンド編集モードに切り替えられる。
ただし、これは自分の環境ではポップアップを出すプラグインのため、ちょっと使いづらいかもしれない。

コマンドラインでは `%` は現在編集中のファイル名:
`!{cmd}` でのみ有効？
有効なコンテキストがちょっとまだわかっていない。
ただし、拡張子だけを取り出したりもできるので `:h filename-modifiers` というヘルプも覚えておく。

バッファの内容を標準入力・標準出力に接続する:
`:read !{cmd}` と `:write {cmd}` のこと。
前者は「コマンドの出力をバッファに吐き出す」、後者は「標準入力としてバッファの内容を使用する」となる。
後者が場合によっては強力かも。
`:write !sh` とすると、バッファの各行をシェルに実行させられる。

外部コマンドを介してバッファの内容をフィルタリングする:
これはビジュアルモードと `:!{cmd}` というシェルコマンドの組合せ。
選択範囲を標準入力に渡しコマンドを実行、コマンドの出力でビジュアル範囲を上書きする。
「指定した `{cmd}` によって `[range]` がフィルタリングされる」とも考えられる。

`:bufdo` コマンド:
`:ls` で列挙されるすべてのバッファに対してExコマンドを実行できる。
おぼえておきたいが `:argdo` の方を理解してマスターしたい。

`:args` コマンド:
引数リストを出力するコマンド。
引数リストという概念から大事。
引数リストは、vimコマンドの起動時に引数として渡されたファイルのリストを表す。
`:args` コマンドはそれ単体だと引数リストの出力だが、引数を渡して実行すると、渡した引数で引数リストが再設定される。
基本的には、存在する複数のファイル名をglob形式で指定することになる。
もちろん、直接指定するのもあり。

また、シェルのようにバッククォートでの出力結果を渡すこともできる。

```
# .chaptersにファイル名が列挙されている場合、引数リストがいい感じに設定される
:args `cat .chapters`
```

argsコマンドを実行すると新たにファイルがバッファにオープンされるが、
すでに開かれたバッファを閉じる、ということにはならない。
ただ、引数リストはちゃんと更新されている（通常 `:ls` コマンドとは異なった内容となる）。
`:args ...` のあとに所望のファイル群に `:argdo` したりする。
`:argdo` の一番簡単な例は `:argdo write` でバッファを一括保存すること。

`:edit!` でバッファの内容を捨てファイルをディスクから読み直す:
リロードの手段としてちゃんと覚えておきたい。

`:qall!` と `:wall` コマンド:
見ての通りのコマンド。
全部に対して実行する、というのも危険な場合はあれど覚えておきたい。

`%:h` でアクティブなバッファのディレクトリ情報だけを取得する:
以下のようなコマンドモードのキーマップを用意すると `%%` で展開できるようになるっぽい。

```vim
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'
```

存在していないディレクトリにファイルを保存:
シェルのmkdirコマンドを使って、以下のようにする。
`!mkdir -p %:h` これは先程の知識も利用している。

`ea` と `gea` でいい感じに単語の末尾で挿入モードに入る:
`ge` は `e` の後ろ方向バージョンだが、 `gea` と暗記すると案外使えるかもしれない。

wordとWORDの定義を認識する:
wordは「英文字、数字、アンダースコアが連続したもの」
WORDは「非空白文字が連続したもの」
ピリオドとアポストロフィはwordとしてカウントされることも覚えておく。
大幅に移動したいときは `W` で移動するのもいいかもしれない。

テキストオブジェクトはモーションそのものではない:
しかしながら、モーションが適用できる場所ではテキストオブジェクトが適用できる。

`_` はブラックホールレジスタ:
`"_d{motion}` とすると、無名レジスタを汚さずに済む。

削除・ヤンク・プットコマンドはレジスタを使う:
`"ayiw` や `"ap` などがノーマルモードでの使い方。
Exコマンドでもレジスタは指定できる。
`:delete c` は、レジスタ `c` に現在のカーソル行をカットする。
`:put c` は、レジスタ `c` の内容をカーソル行の直下に貼り付ける。
`:yank c` も似たような感じになる。
Vimスクリプトを書く際には覚えておきたい。

`"` は無名レジスタ:
レジスタを指定しないと、この無名レジスタを使う。

`0` はヤンクレジスタ:
`y{motion}` という使い方がされると、またその時のみ、無名レジスタに加えて、ヤンクレジスタにも内容がコピーされる。
ヤンクレジスタは無名レジスタに比べて消えにくい、と言える。

`:reg {registers}` で指定したレジスタの内容を表示する:
一気に複数のレジスタを確認できる。
というより、引数なしだと（多分）設定されているすべてのレジスタが閲覧できる。

名前付きレジスタ:
小文字アルファベット1つ1つが名前付きレジスタのため、26種類存在することがわかる。
大文字アルファベットを使うと、指定したレジスタに「追記」される。

クリップボードレジスタは `+` or `*`:
厳密にはシステムごとに違うっぽいが、少なくとも自分が触ってきたMacOSとUbuntuに限っては `+` で問題なさそう。

Expressionレジスタ `=`:
これはちょっと使い方が特殊なので、実用例は後述。

その他のレジスタ（読み取り専用レジスタ）:
コマンドと検索が大事な気がする。

- `%`: 現在のファイルのファイル名
- `#`: 代替ファイルのファイル名？
- `.`: 直前に挿入されたテキスト
- `:`: 直前に実行されたExコマンド
- `/`: 直前に検索された検索パターン

レジスタを使ってビジュルな選択範囲を置換:
ビジュアルモードで `p` とすると、指定されたレジスタの内容で選択範囲が置き換えられる。
レジスタにはビジュアル範囲が入ることになる。
覚えておくと割と効率的に使えるかも。

**コマンドモードもしくは挿入モードで `<C-r>` と入力してからレジスタを指定する:**
今回の復習で最重要の一つの手法。
`<C-r>"` とすると通常のヤンクと同じだが、カーソルの後に挿入されるというのが明白なのが利点だったりする。
`<C-r>=` としてExpressionレジスタを使うと色々な応用が期待できる。
Vim scriptは色々標準装備しておきたい。

**マクロの記録と実行:**
マクロも今回を機に熟練度を上げたい。
ノーマルモードで `q{register}` と入力するとマクロの記録が開始され、再度 `q` とタイプするとそこで終了する。
シーケンスはレジスタに入るため `:reg {register}` で確認できる。
そして実行は、ノーマルモードで `@{register}` とすればよい。
また、 `@@` とすると、直前に呼び出されたマクロを繰り返す。

マクロの考え方のコツ。

> マクロを「直列」に実行するテクニックは脆い。
> クリスマスツリー用の安い電球と同じで、簡単に壊れてしまう。
> マクロを「並列」に実行するテクニックはもっとエラーに強い。

> マクロを記録するというのは、仕事の一単位を行うようにロボットをプログラミングするようなものだ。

> マクロを並列に実行するのは、ベルトコンベアを全く使わずにやるようなものだ。
> ベルトコンベアを使うのではなく、たくさんのロボットを用意するのだ。
> これらのロボットはすべて、ある1つのシンプルな作業だけを行うようにプログラムされている。
> 各ロボットには、するべき仕事が1つだけ割り当てられる。
> うまくいったら...それはよかった。
> 失敗したら...まあ、問題はない。

> 黄金率: マクロを記録するときには、すべてのコマンドは必ず繰り返し可能であるようにしよう。

- カーソルの位置の正規化
  - `^$0` といったモーションを使うと、どの列にいてもまずはカーソル位置を正規化できる
- 繰り返し可能なモーションでターゲットを撃破しよう
- モーションに失敗したら処理は中断する
  - 安全装置！

最後が重要（※デフォルトでは、モーションが失敗すると、Vimはビープ音を鳴らしてくれる）。
マクロがその段階でストップしてくれる、というのはうまく利用できる。

`10@a` とするとマクロは10回実行される:
この数字が適当に決められても問題のないようにマクロを組むと良い。
冪等性。
特に、アットマークと同じ位置にある `22` という数字は試しに使ってみる。
同じ理由で、マクロも普段遣いは `q` レジスタを使えば良さそう。

**`:normal @a` でマクロを並列実行する:**
これを行指向のビジュアルモードで行うと、選択範囲の各行に対してマクロを実行するようにVimに伝える。
というか、マクロもノーマルコマンドの一種なんだ、ということを認識するほうが大事かもしれない。

※並列実行は強烈だが、直列のほうが有効な場合もありうる。

（所感）1行に集中できるのであればとりあえずは気楽なので、まずは1行に対するマクロを考えてみる。

`qA` のように大文字でレジスタを指定するとマクロを追記できる:
レジスタの使い方を考えると納得できる。

`:argdo normal @a` で複数のファイルにマクロを適用する
かなり応用的な気がするので、マクロに大分自信がついてからでいい気がする。

イテレータを評価してリスト中の要素に番号をつける:
最初に `:let i = 1` として、以降マクロ中で `:let i += 1` とし、挿入モードで `<C-r>=i` とすると、いい感じにインクリメントしつつ値をバッファに入力できる。
というより、マクロ中ではExコマンドの実行や、挿入モードからEscで抜ける、などもできることに注目したい。
また、範囲指定して `:normal @q` として並列実行しても、これも結局はマクロは一つずつ上から実行されるので、
ちゃんと値はインクリメントされる。
各行の行頭に数値付きのマークをつけるのは、マクロ典型と言えるかもしれない。

マクロの内容をプレーンテキストのように編集する:
基本的には、マクロはレジスタに文字列を貼り付けたようなものなので、それを操作すれば良い。
マクロを吐き出すには `:put q` のようなputコマンドが便利。
これを編集して、また再びレジスタにヤンクすれば良い。
ヤンクするときは `0"qy$` のようにすると、行末の改行は含めないので覚えておきたい。
※とはいえ、マクロ内には特殊文字が含まれがちなので、単純にappendする場合は `qQ` とかのほうが良さそう。

Vimのレジスタは、テキストの文字列を保持するコンテナに過ぎない:
以下のように、関数を使った汎用的なマクロも組めるかもしれない。
`:let @a=substitute(@a, '\~', 'vU', 'g')`
Vim scriptの関数は `:h function-list` で調べられる。

very magic検索 `\v` を使うとすべての特殊記号に関する規則を正規化できる:
`\v` すると、アンダースコア、大文字小文字のアルファベット、数字を除く、すべての文字が特殊な意味を持つことになる。
普通に正規表現で `()` などを使おうとすると、すべてエスケープする必要が合って面倒だが、
`\v` とすることで正規表現を意図したパターンが書きやすくなる。

nomagic検索 `\V` を使う:
very magicの真逆で、こうすると素直にテキスト検索が出来る。
バックスラッシュ以外は普通の意味を持つことになる。
一般的には、**「正規表現を検索したければ `\v` パターンスイッチを使い、テキストそのものを検索したければ `\V` リテラルスイッチを使う。」**

単語境界デリミタを覚える:
たとえば `/\v<the>` とすることで their などの単語をヒットしないようにすることができる。
very magicを使わないと `/\<the\>` としなければならないことに注意する。

> **パターン**といったら、それは検索フィールドに入力する正規表現（もしくはリテラルなテキスト）のことだ。
> **マッチ**と言ったら、それはドキュメント内で強調表示される何らかのテキストのことだ。

マッチ境界 `\zs, \ze` を理解する:
これは例で理解するほうが良い。
パターンを `/Practical Vim` とすると素直に「Practical Vim」が強調表示されるが、
`/Practical \zsVim` とすると「Practical Vim」というフレーズのVimは強調表示されるが、
Vim単体のものは強調表示されない。
他にも、ダブルクォートに囲まれるもののみマッチさせようとすると、以下のようになる。
`/\v"\zs[^""]+\ze"`
マッチからは除外されていても、パターンのなかでは、ダブルクォートは重要な要素であることに注意が必要。

visual-starがこういうことをやっているのかも？:
`"uyi[/\V<C-r>u<CR>` こうすることで、レジスタuにヤンクしてその内容でパターン検索、という形にできる。
レジスタを介するこのやり方は汎用性が高そう。

Vim scriptの関数中でレジスタを参照したいときは `@u` とする:
`escape(@u, '/\')` とすると「レジスタu中のスラッシュ・バックスラッシュをエスケープする」という具合。

**検索のマッチの末尾にカーソルをオフセットする:**
`/vim/e` のように、 `/e` を付け加えると、ジャンプする先がマッチの末尾になる。
これによって、 `a` コマンドから単語に数文字付け加える、ということが可能になる。
これはドットコマンドとうまく組合せられるかもしれない。
この類のものは `:h search-offset` で調べられる（検索オフセット）。
あとからこれが必要と気づいたときには、 `//e` とすることで前回のパターンを再利用できる。

`f` コマンドは大文字にめがけて使うといいかもしれない:
大文字の存在感は大きい。

**`q/` とすることによってコマンドラインウィンドウを表示できる:**
`q:` と同じ要領で編集ができる。
検索コマンドは複雑なので、複雑な検索がやりたいときは思い出すといいかもしれない。

現在のビジュアルな選択範囲の検索:
これは以下のVim scriptを研究したい。

```vim
# xnoremapは「ビジュアルモードには適用されるが、選択モードでは適用されない」というもの
# <C-R>=@/の部分は<C-r>/じゃだめなんだろうか？
xnoremap * :<C-u>call <SID>VSetSearch()<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call <SID>VSetSearch()<CR>?<C-R>=@/<CR><CR>

# /レジスタの内容を書き換えている
function! s:VSetSearch()
  let temp = @s
  norm! gv"sy # gvは直前の選択範囲を再利用する
  let @/ = '/V' . substitute(escape(@s, '/\'), '\n', '\\n', 'g')
  let @s = temp
endfunction
```

直前の検索パターンを流用する:
無意識でやっていることが多いが、改めて再認識する。

> 置換コマンドが2つのステップで構成されているところがポイントだ。
> つまり、パターンを組み立てることと、適切な置換文字列を考えること。
> この方法を使えば、いつだって、置換コマンドをこれら2つの作業に分割できる。

visual-starなんかも有効活用できる。
まずvisual-starでパターンを決めてから（マッチを確認し）、 `:%s//.../gc` とすればよい。

置換文字列でVim script式評価を使う:
まず、Vim scriptでは、レジスタの内容を `@{register}` で参照できる。
置換文字列においては `\=` のあとにVim scriptを書くことでそれが評価される。
`:%s//\=@0/g` は「直前の検索パターンをヤンクレジスタの内容で置き換えろ」という命令になる。

レジスタをVim scriptで書き換える:
練習用。
`:let @a = 'Practical Vim'` はレジスタaを設定している。

部分マッチを使ってCSVのフィールドを入れ替える:
正規表現パターンにおけるマッチのキャプチャの例として知っておく。

```
/\v^([^,]*),([^,]*),([^,]*)$
:%s//\3,\2,\1
```

`\x` の部分が、部分マッチの参照となっている。
Vim scriptの関数だと `submatch(x)` が同等っぽい（？）

複数のファイルに置換コマンドを実行する:
`:argdo %s//Practical/g` のようにする。
パターンにマッチするものがなかったときはエラーを吐くが、これを抑制したい場合は、
置換コマンドの部分を `%s//Practical/ge` のように `e` フラグを指定すれば良い。

**ターゲットのパターンを含んでいるファイルのリストを作成する:**
vimgrepも同期的ではあるものの便利に活用できる例。
Vimに組み込みの検索エンジンを使うので、全く同じパターンを流用できるのがいいところ。
`:vimgrep /<C-r>// **/*.txt` のようにすると前回の検索パターンでvimgrepできて、ファイルがオープンされる。
※globの復習だが `./**/*.{ext}` のようにすれば、再帰的にすべてのディレクトリを舐めることになる。

vimgrepが返す各マッチはquickfixリストに記録される:
vimgrepの後に `:copen` としてquickfixリストをブラウズできる。
Qargsという、quickfixリストの内容で引数リストを更新するコマンドを追加するプラグインが、
実践Vimの作者から提供されている。
これを利用すると、以下のような一連のコマンドが考えられる。

```vim
# \zeまでがマッチするようなパターン
/Pragmatic\ze Vim
:vimgrep /<C-r>// **/*.txt
:Qargs
:argdo %s//Practical/g
# updateコマンドは、変更が合ったファイルのみ保存される
:argdo update
```

また、最後の3つのコマンドはバーティカルバーによって1つにまとめられる。

```vim
:Qargs | argdo %s//Practical/g | update
```

**Vimにおけるバーティカルバーは、Unixのシェルにおけるセミコロンと同等。**
Vim scriptのワンライナーを書くことは少ないかもしれないが、覚えておきたい。

**グローバルコマンド:**

> `:global` コマンドは、**Exコマンド**のパワーとVimの**パターンマッチ**機能とを結合する。
> これを使って、指定したパターンにマッチする各行に、Exコマンドを実行できる。
> ドットの公式やマクロと並んで、 `:global` コマンドは、繰り返し作業を効率的に行うための、Vimの強力なツールなのだ。

`[range] global[!] /{pattern}/ [cmd]`

rangeを与えないデフォルトでは、ファイル全体 `%` となる。
他のExコマンド `:delete, :substitute, :normal` と大きく異なり、ほとんどのデフォルトの範囲はカーソル行 `.` である。

patternはVimの検索機構なので、空にしておくと現在の検索パターンを自動的に使ってくれる。
その場合は `//` とだけ入力すれば良い。

cmdはglobal以外のコマンドを指定できる。
デフォルトは `:print` コマンドが使われるので、表示されるだけで何もしない。
ドキュメント中のテキストを操作するExコマンドを指定すると便利なことが多い。

`:global!` もしくは `:vglobal` は、パターンマッチ「していない」行に作用する。

レジスタにTODOアイテムを収集する:
yankコマンドを併用して、指定したレジスタにTODOの行をヤンクする。
`:argdo` とさらに併用すると、複数ファイルからかき集めることもできる。

```vim
# 空のマクロを記憶させることでレジスタを消去する
qaq
:g/TODO/yank A
```

Vim組み込みの `:sort` コマンドを使う:
範囲指定すれば部分的に使える場面は多そう。
ただ、コードフォーマッタに任せたくなることが多そう。

globalコマンドに渡すExコマンドも範囲を受け取れることを理解する:
**Exコマンドは常にそれ自体が範囲を受け取れることを思い出す。**
`:g/{pattern}/[range][cmd]`

以下のコマンドは、CSSの波括弧内のみをsortするglobalコマンドの応用（難しい）。
`:g/{/ .+1,/}/-1 sort`
sortの範囲がちょっと難しいが、「現在行（≒各 `/{/` のマッチ行）の1つ下の行から、 `/}/` のマッチ行の1つ上の行まで」という意味になる。

**quickfixリスト:**
errorformatと呼ばれるものに適合するように出力をパースすることで、quickfixリストが作れるっぽい。

> Vimのquickfixリストは、外部ツールをVimで行う作業に組み込むための核となる機能だ。
> これは非常にシンプルに、エラーがあると報告されたファイルの「ファイル名・行番号・桁番号（オプション）・メッセージ」で構成されるアドレス群を管理するものだ。

**grep/vimgrepなどを使ってプロジェクト全体を検索する:**

> vimgrepコマンドなら、Vimにネイティブな検索エンジンを使って複数ファイルからパターンを検索できることを見てみよう。
> これには代償もある。
> つまり、vimgrepは他の専用プログラムほどには高速ではない。

Vimの `:grep` コマンドは外部プログラムgrepのラッパー:
`:grep Waldo *` は `grep -n Waldo *` を実行しているのと同じ。
`:grep` コマンドもquickfixリストを作る。

**vimgrepコマンド:**

`:vim[grep][!] /{pattern}/[g][j] {file} ...`

gフラグをつけると、1行の複数のマッチを捉える。
jフラグをつけると、最初のマッチへのジャンプをキャンセルできる。
quickfixリストが作りたいだけならつけたほうが良さそう。

file引数は必須。
ファイル名、ワイルドカード、バッククォート式、これらの組合せたものなど、
argsコマンドと同じ引数が指定可能。
`*` ワイルドカードはディレクトリ内のすべてのファイルにマッチする。
`**` ワイルドカードは、指定したディレクトリまたはそのサブディレクトリにあるすべてのファイルにマッチする。
`##` は引数リストに含まれている各ファイルの名前に展開される。

vimgrepの利点は現在のバッファのマッチを確認することで、パターンを正しく組み立てやすいこと。
`:vim /<C-r>// **` とすると現在のパターンで検索してくれる。
注意点として、パターンを空にするのはダメ、ということ。
`<C-r>/` でレジスタから実際のパターン文字列を引っ張ってくる必要がある。

